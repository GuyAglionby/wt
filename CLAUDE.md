# wt

Single-file bash tool (`wt`) for managing git worktrees.

# Testing instructions

After making any changes to `wt`, you should add the relevant tests. Tests in this repository are handled by `bats`. Before committing, verify all tests pass with `bats test/`. 

## Worktree resolution helpers

All worktree/branch lookups must go through the existing helper functions. Never reimplement this logic inline.

- `get_worktree_path(repo_root, branch)` -- derives the directory path for a branch's worktree (`{parent}/worktree--{repo}--{branch}`)
- `normalize_branch(branch)` -- strips the `worktree--*--` directory prefix to recover a plain branch name
- `find_worktree_for_branch(repo_root, branch)` -- looks up a worktree path by branch name (parses `git worktree list --porcelain`)
- `find_branch_for_worktree(repo_root, worktree_path)` -- reverse lookup: branch name from worktree path
- `resolve_worktree(arg, repo_root)` -- accepts either a path or branch name and returns the validated worktree path. This is the main entry point used by commands.

Any new command that accepts a branch or worktree argument should call `resolve_worktree`, not hand-roll its own validation.

## Shell IPC signals

`wt` runs as a subprocess, so it cannot directly `cd` the user's shell or activate a virtualenv. Instead, commands emit signal lines on stdout:

- `__WT_CD__:<path>` -- tells the shell wrapper to `cd` to the given path
- `__WT_ACTIVATE__:<path>` -- tells the shell wrapper to activate the venv at that path

The shell wrapper function (generated by `wt init`) parses these signals and acts on them. Any new command that needs to change the shell's working directory or environment must use these signals rather than attempting to `cd` or `source` directly.

## Metadata storage

Per-worktree metadata lives in `.git/worktrees/{worktree_name}/`:

- `starting_commit` -- the commit HEAD pointed to when the worktree was created (via `cmd_add`). Used by the branch deletion heuristic.
- `agent_base/` -- snapshot of agent files at worktree creation time, used for three-way merge on sync.

`worktree_name` is obtained via `get_worktree_name()`.

## Branch deletion heuristic

When removing a worktree (`_rm_single`), the branch deletion decision follows this cascade:

1. `--force-delete-branch` → always delete
2. No `starting_commit` recorded → retain
3. HEAD equals `starting_commit` → delete (no work done)
4. HEAD differs from `starting_commit` → call `_check_branch_merged`:
   - **Fast local check (remote)**: is branch HEAD reachable from `remote/default_branch`? Catches merge commits (hashes preserved) and fast-forwards without any API calls.
   - **Local branch check**: is branch HEAD reachable from any other local branch (e.g. local main not yet pushed, or another branch like develop)? If so, the branch is considered merged and is deleted.
   - **GitHub PR check**: uses `gh` to find a merged PR for the branch. If the PR is merged and local HEAD is at or behind the PR's final commit (`headRefOid`), the branch is safe to delete. Handles squash/rebase merges where commit hashes differ, and handles the common case where the remote branch was deleted after merge.
   - If `gh` is not installed, or there's no PR, or the PR isn't merged → falls through to the original "retain" behavior.

Helper functions for the merge check:
- `_get_github_remote(repo_root)` -- resolves the git remote name by matching `gh repo view`'s `nameWithOwner` against `git remote -v` URLs
- `_get_default_branch(repo_root, remote)` -- resolves the default branch name via `gh`, falling back to `refs/remotes/{remote}/HEAD`, then `"main"`
- `_check_branch_merged(repo_root, branch, branch_head)` -- orchestrates the merge detection; returns `delete:<reason>` or `retain:<reason>` via stdout

## Bash compatibility

Target is bash 3.2 (macOS system bash). Do not use bash 4+ features:

- No associative arrays (`declare -A`, `local -A`)
- No `readarray` / `mapfile`
- No `${var,,}` / `${var^^}` case conversion
- No `|&` (pipe stderr)
- No negative array indexing (`${arr[-1]}`)

For set-membership lookups, store newline-delimited strings and use `grep -qxF`.

## Environment management

Worktrees depend on the main repo, never on each other. The main worktree outlives all linked worktrees, so sharing its resources (venv, .env) is safe. A worktree's own resources are ephemeral — other worktrees must not reference them.

`cmd_add` always symlinks `.venv` to the main worktree's venv — it never creates an independent venv. If run from a linked worktree whose `.venv` is a real directory, it falls back to main's venv instead.

`_create_venv()` is the single entry point for creating a standalone venv. `cmd_venv` uses it. Future package manager support (poetry) should be added here.

## Versioning

We use semver. When making changes, update the version in `WT_VERSION` in `wt` and add an entry to `CHANGELOG.md`.

## Command naming

- User-facing commands: `cmd_<name>()`
- Internal helpers: `_<name>()`

